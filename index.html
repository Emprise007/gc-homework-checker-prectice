<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>일일 숙제 관리 및 달력</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* 상단 정렬 */
            padding-top: 50px;
            background-color: #f4f4f4;
        }

        /* ---------------------- 전체 레이아웃 ---------------------- */
        .container {
            display: flex;
            gap: 40px; /* 숙제 섹션과 달력 섹션 사이 간격 */
            max-width: 1200px;
            width: 100%;
        }

        /* ---------------------- 숙제 및 캐릭터 섹션 ---------------------- */
        .task-section {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            flex: 1; /* 남은 공간을 채우도록 설정 */
            min-width: 400px;
        }

        .character-status {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .task-list {
            list-style: none;
            padding: 0;
        }

        .task-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .task-item:last-child {
            border-bottom: none;
        }

        .task-item.completed {
            text-decoration: line-through;
            color: #aaa;
        }

        .toggle-all {
            margin-top: 20px;
            padding: 10px 15px;
            background-color: #5cb85c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            font-size: 16px;
        }

        /* ---------------------- 달력 섹션 ---------------------- */
        .calendar-section {
            width: 400px; /* 달력 너비 고정 */
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .calendar-header button {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            text-align: center;
        }

        .calendar-grid .day-name {
            font-weight: bold;
            color: #333;
            padding: 5px 0;
        }

        .calendar-grid .day {
            padding: 8px 0;
            border-radius: 4px;
            font-size: 14px;
            position: relative;
        }

        /* 달력 날짜 상태 스타일 */
        .day.incomplete { background-color: #fdd; } /* 미완료 (빨간색 계열) */
        .day.complete { background-color: #dfd; } /* 완료 (초록색 계열) */
        .day.today { border: 2px solid #5cb85c; font-weight: bold; background-color: #eaf7ea; }
    </style>
</head>
<body>
    <div class="container">
        <div class="task-section">
            <h1 class="character-status" id="character-status">캐릭터: </h1>
            <h2 style="margin-top: 0;">오늘의 숙제</h2>
            <ul class="task-list" id="task-list">
                </ul>
            <button class="toggle-all" onclick="toggleAllTasks()">오늘 숙제 전체 완료/해제</button>
        </div>

        <div class="calendar-section">
            <div class="calendar-header">
                <button onclick="changeMonth(-1)">&#9664;</button>
                <h2 id="current-month-year"></h2>
                <button onclick="changeMonth(1)">&#9654;</button>
            </div>
            <div class="calendar-grid" id="calendar-grid">
                <div class="day-name">일</div>
                <div class="day-name">월</div>
                <div class="day-name">화</div>
                <div class="day-name">수</div>
                <div class="day-name">목</div>
                <div class="day-name">금</div>
                <div class="day-name">토</div>
                </div>
        </div>
    </div>

    <script>
        // ---------------------- 데이터 및 설정 ----------------------
        const DAILY_PROGRESS_KEY = 'dailyProgressData';
        const LAST_RESET_KEY = 'lastResetDate';

        const characters = ['A', 'B', 'C', 'D'];
        const tasks = {
            'A': ['A-숙제1', 'A-숙제2'],
            'B': ['B-숙제1', 'B-숙제2', 'B-숙제3'],
            'C': ['C-숙제1'],
            'D': ['D-숙제1', 'D-숙제2']
        };

        // 전역 변수
        let dailyProgress = {}; // 모든 날짜의 진척도 데이터 { 'yyyymmdd': { 'taskName': true/false, ... }, ... }
        let progress = {};      // 오늘 날짜의 진척도 데이터 (dailyProgress[todayKey]와 연결)
        let lastReset = '';     // 마지막으로 리셋된 날짜 (yyyymmdd)
        let todayKey;           // 오늘 날짜 (yyyymmdd)
        let totalTasks = 0;

        // 달력 관련 변수
        let currentCalendarDate = new Date(); // 현재 달력에 표시할 년월

        // ---------------------- 유틸리티 함수 ----------------------

        /** 오늘 날짜를 'yyyymmdd' 형식으로 반환 */
        function getTodayKey() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}${month}${day}`;
        }

        /**
         * 진척도 데이터를 로컬 스토리지에 저장합니다.
         * 이 함수는 무한 루프를 막기 위해 데이터가 실제로 변경되는 시점에만 호출되어야 합니다.
         * @param {string} dateKey - 저장할 날짜 키 (yyyymmdd)
         */
        function saveDailyProgress(dateKey) {
            // 현재 progress 객체(오늘 날짜 데이터)를 전체 dailyProgress에 반영
            dailyProgress[dateKey] = progress;
            // 전체 데이터를 저장
            localStorage.setItem(DAILY_PROGRESS_KEY, JSON.stringify(dailyProgress));
            // console.log(`Data saved for ${dateKey}.`);
        }

        /**
         * 새로운 날짜가 되었는지 확인하고 리셋을 적용합니다.
         * @param {boolean} shouldSave - 리셋 시 이전 날짜 데이터를 저장할지 여부 (주기적 체크 시에만 true)
         * @returns {boolean} 리셋이 발생했는지 여부
         */
        function checkAndApplyReset(shouldSave) {
            if (todayKey === lastReset) {
                return false; // 오늘 이미 리셋되었거나 작업 중이므로 리셋하지 않음
            }

            // 날짜가 바뀌었으므로 리셋 수행
            const lastDayKey = lastReset; // 어제 날짜
            const resetOccurred = lastReset !== '';

            if (resetOccurred && shouldSave) {
                // 리셋 직전, 어제 날짜의 최종 진행 상황을 저장
                saveDailyProgress(lastDayKey);
            }

            // 오늘 날짜의 빈 progress 객체로 초기화
            const newProgress = {};
            characters.forEach(char => {
                tasks[char].forEach(task => {
                    newProgress[task] = false;
                });
            });
            progress = newProgress; // progress 객체를 새 객체로 교체
            dailyProgress[todayKey] = progress; // 전체 데이터에도 오늘 날짜로 반영
            localStorage.setItem(LAST_RESET_KEY, todayKey);
            lastReset = todayKey;
            
            // console.log("Daily reset applied.");
            return true;
        }

        /**
         * 로컬 스토리지에서 데이터를 로드하고 변수를 초기화합니다.
         * 이 함수는 데이터 로드만 하고 저장은 하지 않습니다!
         */
        function initializeVariables() {
            // 1. 오늘 날짜 키 설정
            todayKey = getTodayKey();

            // 2. 전체 진행 데이터 로드
            const storedProgress = localStorage.getItem(DAILY_PROGRESS_KEY);
            if (storedProgress) {
                dailyProgress = JSON.parse(storedProgress);
            } else {
                dailyProgress = {};
            }

            // 3. 마지막 리셋 날짜 로드
            const storedLastReset = localStorage.getItem(LAST_RESET_KEY);
            lastReset = storedLastReset || '';

            // 4. 리셋 체크 및 오늘 데이터 설정
            // 로드 시점에서는 shouldSave를 false로 설정하여 saveDailyProgress 호출을 막습니다.
            checkAndApplyReset(false); 
        }

        // ---------------------- 렌더링 함수 ----------------------

        /** 숙제 목록을 렌더링합니다. */
        function renderTasks() {
            const taskList = document.getElementById('task-list');
            taskList.innerHTML = '';
            totalTasks = 0;
            let completedTasks = 0;

            characters.forEach(char => {
                tasks[char].forEach(task => {
                    const isCompleted = progress[task] || false;
                    const listItem = document.createElement('li');
                    listItem.className = `task-item ${isCompleted ? 'completed' : ''}`;
                    listItem.setAttribute('data-task', task);
                    listItem.onclick = () => toggleTask(task);

                    listItem.innerHTML = `
                        <span>[${char}] ${task}</span>
                        <span>${isCompleted ? '✅' : '⬜'}</span>
                    `;
                    taskList.appendChild(listItem);
                    totalTasks++;
                    if (isCompleted) {
                        completedTasks++;
                    }
                });
            });

            // 캐릭터 상태 업데이트
            const statusElement = document.getElementById('character-status');
            const statusText = `캐릭터: ${completedTasks} / ${totalTasks} 완료`;
            statusElement.innerHTML = statusText;

            // 로컬 스토리지에 오늘 데이터 저장 (이 시점에 저장해야 UI 변경과 동기화됨)
            saveDailyProgress(todayKey);
        }

        /** 달력을 렌더링합니다. */
        function renderCalendar() {
            const header = document.getElementById('current-month-year');
            const grid = document.getElementById('calendar-grid');
            
            // 현재 달력에 표시할 년/월 설정
            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth(); // 0-11
            
            header.textContent = `${year}년 ${month + 1}월`;

            // 해당 월의 첫 번째 날 (1일)
            const firstDayOfMonth = new Date(year, month, 1);
            // 해당 월의 마지막 날
            const lastDayOfMonth = new Date(year, month + 1, 0);
            
            // 날짜 칸 초기화 (요일 이름은 유지)
            // .day-name 이 7개 있으므로 7번째 자식부터 제거
            while (grid.children.length > 7) {
                grid.removeChild(grid.lastChild);
            }

            // 1일이 시작하는 요일의 인덱스 (일요일 0, 월요일 1, ...)
            const startDayIndex = firstDayOfMonth.getDay();

            // 공백 채우기
            for (let i = 0; i < startDayIndex; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'day empty';
                grid.appendChild(emptyDay);
            }

            // 날짜 채우기
            for (let d = 1; d <= lastDayOfMonth.getDate(); d++) {
                const dayDiv = document.createElement('div');
                const date = new Date(year, month, d);
                const dateKey = `${year}${String(month + 1).padStart(2, '0')}${String(d).padStart(2, '0')}`;
                
                dayDiv.className = 'day';
                dayDiv.textContent = d;

                // 오늘 날짜 표시
                if (dateKey === todayKey) {
                    dayDiv.classList.add('today');
                }

                // 과거 날짜의 진척도 표시
                if (dailyProgress[dateKey]) {
                    let dayProgress = dailyProgress[dateKey];
                    let taskCount = 0;
                    let completedCount = 0;

                    for (const task in dayProgress) {
                        taskCount++;
                        if (dayProgress[task]) {
                            completedCount++;
                        }
                    }

                    // 완료 상태 결정: 모든 숙제를 완료했을 때만 'complete'
                    if (taskCount > 0) {
                         if (completedCount === taskCount) {
                            dayDiv.classList.add('complete');
                        } else if (completedCount < taskCount) {
                            dayDiv.classList.add('incomplete');
                        }
                    }
                }
                
                grid.appendChild(dayDiv);
            }
        }

        /** 전체 UI를 렌더링합니다. */
        function render() {
            renderTasks();
            renderCalendar();
        }

        // ---------------------- 이벤트 핸들러 ----------------------

        /**
         * 특정 숙제를 완료/미완료 처리하고 UI를 갱신합니다.
         * @param {string} taskName - 숙제 이름
         */
        function toggleTask(taskName) {
            progress[taskName] = !progress[taskName];
            render(); // render 내부에서 saveDailyProgress 호출됨
        }

        /** 모든 숙제를 완료/미완료 처리합니다. */
        function toggleAllTasks() {
            const allCompleted = totalTasks > 0 && Object.values(progress).every(status => status === true);
            
            // 전체 완료 상태를 반전시킵니다.
            characters.forEach(char => {
                tasks[char].forEach(task => {
                    progress[task] = !allCompleted;
                });
            });

            render(); // render 내부에서 saveDailyProgress 호출됨
        }

        /**
         * 달력의 월을 변경합니다.
         * @param {number} delta - -1 (이전 달) 또는 1 (다음 달)
         */
        function changeMonth(delta) {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + delta);
            renderCalendar();
        }

        // ---------------------- 초기화 및 주기적 체크 ----------------------
        
        /** 주기적으로 날짜 리셋을 체크하고 필요시 UI를 렌더링합니다. */
        function checkResetAndRender() {
            todayKey = getTodayKey(); // 현재 시간을 기준으로 오늘 날짜를 업데이트
            
            // 날짜가 바뀌었으면 리셋을 적용하고 렌더링합니다.
            // 리셋 시에만 shouldSave=true로 설정하여 이전 날짜의 최종 데이터를 저장합니다.
            if (checkAndApplyReset(true)) { 
                render();
            }
            // 리셋이 발생하지 않았더라도 달력의 today 표시를 위해 캘린더만 렌더링 (옵션, 1분에 한 번이므로 큰 부담 없음)
            renderCalendar(); 
        }

        // 초기화
        initializeVariables();
        render(); // 최초 렌더링

        // 1분마다 리셋을 체크합니다. (무한 루프 방지를 위해 setInterval 사용)
        setInterval(checkResetAndRender, 60000); 
    </script>
</body>
</html>
